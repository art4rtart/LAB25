using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class Her0inEnemy : MonoBehaviour
{
	Animator anim;
	Rigidbody rgbd;
	NavMeshAgent navMesh;
	Transform target;
	CapsuleCollider csCollider;

	[Header("Infectee")]
	public LayerMask humanMask;
	public float findRadius;
	public float attackRadius;
	bool followTarget;
	bool settingTrigger;
	bool corTrigger;

	[Header("if generated by generator check")]
	public bool isGenerated = false;

	void OnEnable()
	{
		if (isGenerated)
		{
			target = GameObject.FindWithTag("Player").transform;
		}
	}

	void Awake()
    {
		anim = GetComponent<Animator>();
		rgbd = GetComponent<Rigidbody>();
		navMesh = GetComponent<NavMeshAgent>();
		myChange = GetComponentInParent<ChangeRagDoll>();
		csCollider = GetComponent<CapsuleCollider>();
	}

	void Update()
    {
		AnimatorStateInfo info = anim.GetCurrentAnimatorStateInfo(0);

		if (!followTarget && !isGenerated)
		{
			Collider[] humanInRadius = Physics.OverlapSphere(transform.position, findRadius, humanMask);

			for (int i = 0; i < humanInRadius.Length; i++)
			{
				if (humanInRadius[i].transform.CompareTag("Player"))
				{
					target = humanInRadius[i].transform;
					navMesh.SetDestination(target.position);
					StartCoroutine(Follow());
					followTarget = true;
				}
			}
		}

		if (navMesh.enabled && target != null) navMesh.SetDestination(target.transform.position);

		if(info.IsName("Attack"))
		{
			Vector3 calcuatledtarget = new Vector3(target.transform.position.x, this.transform.position.y, target.transform.position.z);
			transform.LookAt(calcuatledtarget);
		}
	}

	IEnumerator Follow()
	{
		navMesh.speed = 3f;
		anim.SetBool("Run", true);

		yield return new WaitForSeconds(0.2f);

		navMesh.enabled = true;

		while(navMesh.remainingDistance >= navMesh.stoppingDistance)
		{
			yield return null;
		}

		navMesh.enabled = false;
		anim.SetBool("Run", false);

		StartCoroutine(Attack());
	}

	IEnumerator Attack()
	{
		anim.SetTrigger("Attack");
		yield return new WaitForSeconds(1.5f);

		navMesh.speed = 0f;
		navMesh.enabled = true;

		if (navMesh.enabled && navMesh.remainingDistance >= navMesh.stoppingDistance)
		{
			StartCoroutine(Follow());
		}

		if (navMesh.enabled && navMesh.remainingDistance <= navMesh.stoppingDistance)
		{
			StartCoroutine(Attack());
		}
	}

	private void OnDrawGizmosSelected()
	{
		if (!isGenerated)
		{
			Gizmos.color = Color.red;
			Gizmos.DrawWireSphere(transform.position, findRadius);
		}

		else return;
	}

	//infectee attributes
	public int hp;
	public int maxHp;
	private ChangeRagDoll myChange;
	public RagDollDIeCtrl myRagDollCtrl;
	public Vector3 hitPos;

	public void ApplyDamage(int damage)
	{
		hp -= damage;

		if (hp <= 0)
		{
			myRagDollCtrl.speed = navMesh.velocity.magnitude;
			myRagDollCtrl.AttackedPos = hitPos;
			Die();
		}
	}

	private void Die()
	{
		myChange.StartCoroutine(myChange.ChangeRagdoll());
	}

	void OnCollisionEnter(Collision other)
	{
		if (other.gameObject.CompareTag("Wall"))
		{
			if (!settingTrigger)
			{
				rgbd.constraints = RigidbodyConstraints.FreezePositionY;
				// csCollider.isTrigger = true;

				if (isGenerated)
				{
					// rgbd.isKinematic = true;
					StartCoroutine(Follow());
				}

				settingTrigger = true;
				Debug.Log("OK");
			}

			else return;
		}
	}
}
